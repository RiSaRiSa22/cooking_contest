---
phase: 02-admin-dishes
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/competitionStore.ts
  - src/hooks/useCompetition.ts
  - src/hooks/usePhotoUpload.ts
  - src/lib/compress.ts
  - src/components/competition/PhaseBanner.tsx
  - src/screens/Admin/AdminScreen.tsx
  - src/screens/Admin/modals/ConfirmModal.tsx
  - src/router.tsx
autonomous: true

must_haves:
  truths:
    - "AdminScreen renders at /admin/:code with 4 tab buttons and tab content switching"
    - "competitionStore holds competition, dishes, participants state and resets on unmount"
    - "useCompetition fetches competition + dishes + participants on mount and subscribes to Realtime phase changes"
    - "PhaseBanner shows current phase name with appropriate styling"
    - "compress.ts resizes images to max 800px and outputs JPEG at 0.72 quality"
    - "usePhotoUpload compresses and uploads to Supabase Storage, returning public URLs"
  artifacts:
    - path: "src/store/competitionStore.ts"
      provides: "Zustand store for competition runtime state"
      exports: ["useCompetitionStore"]
    - path: "src/hooks/useCompetition.ts"
      provides: "Data fetching + Realtime subscription hook"
      exports: ["useCompetition"]
    - path: "src/hooks/usePhotoUpload.ts"
      provides: "Photo compression + upload pipeline hook"
      exports: ["usePhotoUpload"]
    - path: "src/lib/compress.ts"
      provides: "Canvas-based image compression utility"
      exports: ["compressImage"]
    - path: "src/components/competition/PhaseBanner.tsx"
      provides: "Phase indicator banner component"
      exports: ["PhaseBanner"]
    - path: "src/screens/Admin/AdminScreen.tsx"
      provides: "Admin screen shell with tab navigation"
      exports: ["AdminScreen"]
    - path: "src/screens/Admin/modals/ConfirmModal.tsx"
      provides: "Reusable confirmation modal (shared by 02-02 and 02-03)"
      exports: ["ConfirmModal"]
  key_links:
    - from: "src/screens/Admin/AdminScreen.tsx"
      to: "src/hooks/useCompetition.ts"
      via: "useCompetition(competitionId) call on mount"
      pattern: "useCompetition\\("
    - from: "src/hooks/useCompetition.ts"
      to: "src/store/competitionStore.ts"
      via: "populates store with fetched data"
      pattern: "useCompetitionStore"
    - from: "src/router.tsx"
      to: "src/screens/Admin/AdminScreen.tsx"
      via: "route /admin/:code renders AdminScreen"
      pattern: "AdminScreen"
    - from: "src/hooks/usePhotoUpload.ts"
      to: "src/lib/compress.ts"
      via: "compressImage() before storage upload"
      pattern: "compressImage"
---

<objective>
Create the data layer (competitionStore, useCompetition, usePhotoUpload, compress) and AdminScreen shell with tab navigation and PhaseBanner. This is the foundation all Phase 02 UI builds on.

Purpose: Every admin tab reads from competitionStore. The store, hooks, and AdminScreen shell must exist before any tab content or Edge Function wiring.
Output: Working AdminScreen at /admin/:code with 4 empty tab placeholders, live competition data from Supabase, Realtime phase subscription, and ready-to-use photo upload pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-admin-dishes/02-RESEARCH.md
@.planning/phases/01-foundation-auth/01-03-SUMMARY.md
@.planning/phases/01-foundation-auth/01-04-SUMMARY.md

Key existing files to reference:
@src/store/sessionStore.ts (Zustand pattern with persist)
@src/router.tsx (current routes + RequireSession guard)
@src/lib/supabase.ts (Supabase client)
@src/types/database.types.ts (all table types)
@src/components/ui/index.ts (Button, Input, Modal, Toast exports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Data layer ‚Äî competitionStore + useCompetition + compress + usePhotoUpload</name>
  <files>
    src/store/competitionStore.ts
    src/hooks/useCompetition.ts
    src/hooks/usePhotoUpload.ts
    src/lib/compress.ts
  </files>
  <action>
    **1. Create `src/store/competitionStore.ts`**
    Follow the Zustand v5 pattern from sessionStore.ts but WITHOUT persist middleware (data is server-authoritative).

    Store interface:
    ```typescript
    interface CompetitionStore {
      competition: Competition | null
      dishes: DishWithPhotos[]
      participants: Participant[]
      isLoading: boolean
      error: string | null
      setCompetition: (c: Competition) => void
      setDishes: (dishes: DishWithPhotos[]) => void
      setParticipants: (participants: Participant[]) => void
      updatePhase: (phase: string) => void
      addDish: (dish: DishWithPhotos) => void
      updateDish: (dish: DishWithPhotos) => void
      removeDish: (dishId: string) => void
      addParticipant: (p: Participant) => void
      setLoading: (b: boolean) => void
      setError: (e: string | null) => void
      reset: () => void  // CRITICAL: reset to initial state on unmount
    }
    ```

    Use `Database['public']['Tables']['competitions']['Row']` for Competition type, etc. Define `DishWithPhotos` as `Dish & { photos: Photo[] }` using the generated types.

    The `reset()` action sets all fields back to initial values (null, [], false, null). This prevents stale data flash when navigating between competitions (Pitfall 4 from research).

    **2. Create `src/hooks/useCompetition.ts`**
    Hook that takes `competitionId: string` parameter:
    - On mount: fetch competition, dishes (from `dishes` table with `*, photos(*)` join), and participants via 3 parallel Supabase SDK queries
    - Admin reads from `dishes` table directly (NOT dishes_public) ‚Äî the `anon_read_dishes` RLS policy allows this
    - Set data into competitionStore
    - Subscribe to Supabase Realtime: `competitions` table UPDATE events filtered by `id=eq.${competitionId}` ‚Äî on change, call `updatePhase(payload.new.phase)`
    - On unmount: remove Realtime channel AND call `reset()` on competitionStore
    - Handle errors via `setError()`

    **3. Create `src/lib/compress.ts`**
    Export `compressImage(file: File): Promise<Blob>`:
    - Constants: MAX_PX = 800, QUALITY = 0.72
    - Create Image from File via `URL.createObjectURL`
    - Calculate scale factor: `Math.min(1, MAX_PX / Math.max(img.width, img.height))`
    - Draw to canvas at scaled dimensions
    - `canvas.toBlob(callback, 'image/jpeg', QUALITY)`
    - Clean up with `URL.revokeObjectURL`
    - Return the Blob (reject on null blob or img.onerror)
    See exact pattern in 02-RESEARCH.md Pattern 3.

    **4. Create `src/hooks/usePhotoUpload.ts`**
    Export `usePhotoUpload()` returning `{ uploadPhotos, isUploading, error }`:
    - `uploadPhotos(files: File[], dishId: string, isExtra?: boolean): Promise<string[]>` ‚Äî compresses each file via `compressImage()`, uploads to Storage bucket `dish-photos` at path `${dishId}/${crypto.randomUUID()}.jpg`, returns array of public URLs
    - Upload files with `Promise.all()` for parallelism (Storage handles concurrent uploads fine)
    - Use `supabase.storage.from('dish-photos').upload()` then `.getPublicUrl()` (synchronous, no await)
    - Track `isUploading` state and errors

    NOTE: Storage anon INSERT policy does not exist yet ‚Äî a migration will be added in Plan 02-02. This hook will work once that policy is in place. For now, just implement the code.
  </action>
  <verify>
    Run `npx tsc --noEmit` ‚Äî zero errors. All 4 files exist and export their public APIs.
  </verify>
  <done>
    competitionStore has all actions including reset(). useCompetition fetches 3 tables and subscribes Realtime. compressImage resizes to 800px/0.72 JPEG. usePhotoUpload compresses + uploads + returns URLs.
  </done>
</task>

<task type="auto">
  <name>Task 2: AdminScreen shell + PhaseBanner + ConfirmModal + router wiring</name>
  <files>
    src/screens/Admin/AdminScreen.tsx
    src/components/competition/PhaseBanner.tsx
    src/screens/Admin/modals/ConfirmModal.tsx
    src/router.tsx
  </files>
  <action>
    **1. Create `src/components/competition/PhaseBanner.tsx`**
    Reads `competition.phase` from competitionStore. Displays a horizontal banner below the header:
    - `preparation`: amber/gold background, text "Preparazione in corso" with emoji "üë®‚Äçüç≥"
    - `voting`: ember/red background, text "Votazione in corso" with emoji "üó≥Ô∏è"
    - `finished`: sage/green background, text "Gara conclusa" with emoji "üèÜ"
    - Use Tailwind classes + CSS vars from the design system (var(--color-gold), var(--color-ember), var(--color-sage))
    - Full-width, centered text, py-2, font-body text-sm font-semibold
    - Returns null if no competition in store

    **2. Create `src/screens/Admin/modals/ConfirmModal.tsx`**
    Shared utility modal used by both 02-02 (DishesTab delete) and 02-03 (SettingsTab phase advance / vote reset).
    Props: `{ open: boolean, onClose: () => void, onConfirm: () => void, title: string, message: string, confirmLabel?: string, confirmVariant?: 'ember' | 'gold', isLoading?: boolean }`
    - Uses existing Modal component with variant='center'
    - Title (font-display), message paragraph, two buttons: "Annulla" (ghost) and confirm (ember or specified variant)
    - isLoading disables confirm button and shows spinner

    **3. Create `src/screens/Admin/AdminScreen.tsx`**
    Get `code` from `useParams<{ code: string }>()`.
    Get session from `useSessionStore.getSession(code!)`.
    Call `useCompetition(session!.competitionId)` to load data.
    Read `isLoading` and `competition` from competitionStore.

    Tab navigation with `useState<Tab>('piatti')`:
    ```typescript
    const TABS = [
      { id: 'piatti', label: 'Piatti', emoji: 'üçΩÔ∏è' },
      { id: 'partecipanti', label: 'Partecipanti', emoji: 'üë•' },
      { id: 'classifica', label: 'Classifica', emoji: 'üèÜ' },
      { id: 'impostazioni', label: 'Impostazioni', emoji: '‚öôÔ∏è' },
    ] as const
    ```

    Layout structure (matching UI_REFERENCE.md):
    - Sticky header (62px): competition name + code badge
    - PhaseBanner below header
    - Scrollable content area with pb-24 (space for tab bar)
    - Fixed bottom tab bar (64px): 4 tab buttons, active tab has ember underline

    Tab content: render placeholder `<div>` for each tab with "Tab {name} ‚Äî coming soon" text. Plans 02-02 and 02-03 will replace these placeholders.

    Loading state: show centered spinner/text "Caricamento..." while `isLoading`.
    Error state: show error message from store.

    Styling:
    - Background: var(--color-parchment)
    - Header: var(--color-ink) background, white text, competition code in a gold badge
    - Tab bar: white background, border-t, tab buttons with emoji + label stacked vertically
    - Active tab: ember color text + bottom border
    - Use responsive approach (full-width, no max-width cap) consistent with Phase 01

    **4. Update `src/router.tsx`**
    Replace the placeholder `<div>` for `/admin/:code` with `<AdminScreen />` import.
    Keep the `<RequireSession>` wrapper.
  </action>
  <verify>
    Run `npm run build` ‚Äî zero errors. Navigate to `/#/admin/TESTCODE` (with a valid session) ‚Äî AdminScreen renders with header, PhaseBanner, 4 tab buttons, and tab content area.
  </verify>
  <done>
    AdminScreen renders at /admin/:code with header showing competition name, PhaseBanner showing current phase, 4 clickable tabs switching content, and loading/error states. Router updated to use AdminScreen component instead of placeholder.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. All 8 new files exist at their specified paths (including ConfirmModal.tsx)
4. competitionStore exports useCompetitionStore with all actions
5. AdminScreen renders tab navigation and switches between 4 tabs
6. PhaseBanner renders with phase-appropriate color and text
7. Router /admin/:code renders AdminScreen within RequireSession guard
</verification>

<success_criteria>
- AdminScreen loads competition data from Supabase on mount
- Tab switching works (4 tabs, content changes on click)
- PhaseBanner reflects current phase from store
- competitionStore.reset() clears all state
- compressImage produces JPEG blob at max 800px and 0.72 quality
- usePhotoUpload returns public URLs after upload
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-dishes/02-01-SUMMARY.md`
</output>
