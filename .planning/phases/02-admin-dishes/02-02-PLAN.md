---
phase: 02-admin-dishes
plan: "02"
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - supabase/functions/dish-write/index.ts
  - supabase/functions/dish-delete/index.ts
  - src/components/dishes/DishCard.tsx
  - src/components/dishes/PhotoGrid.tsx
  - src/screens/Admin/modals/AddDishModal.tsx
  - src/screens/Admin/modals/ConfirmModal.tsx
  - src/screens/Admin/tabs/DishesTab.tsx
autonomous: false

must_haves:
  truths:
    - "Admin can create a dish with name, chef name, optional fields, and photo uploads"
    - "Admin can edit any existing dish (name, chef, ingredients, recipe, story, photos)"
    - "Admin can delete any dish with confirmation ‚Äî DB record and Storage blobs both removed"
    - "DishesTab shows all dishes with photos, chef name, and edit/delete action buttons"
    - "Photos are compressed client-side before upload to Storage"
    - "Anon users can upload to dish-photos Storage bucket"
  artifacts:
    - path: "supabase/functions/dish-write/index.ts"
      provides: "Edge Function for creating/updating dishes + photo records"
      contains: "DishWriteSchema"
    - path: "supabase/functions/dish-delete/index.ts"
      provides: "Edge Function for deleting dish + Storage blobs"
      contains: "storage.from.*remove"
    - path: "src/components/dishes/DishCard.tsx"
      provides: "Dish card component with photo, chef, actions"
      exports: ["DishCard"]
    - path: "src/components/dishes/PhotoGrid.tsx"
      provides: "3-column photo grid component"
      exports: ["PhotoGrid"]
    - path: "src/screens/Admin/modals/AddDishModal.tsx"
      provides: "Modal for create/edit dish with photo upload"
      exports: ["AddDishModal"]
    - path: "src/screens/Admin/modals/ConfirmModal.tsx"
      provides: "Reusable confirmation modal"
      exports: ["ConfirmModal"]
    - path: "src/screens/Admin/tabs/DishesTab.tsx"
      provides: "Dishes tab with full CRUD wiring"
      exports: ["DishesTab"]
  key_links:
    - from: "src/screens/Admin/tabs/DishesTab.tsx"
      to: "supabase/functions/dish-write"
      via: "supabase.functions.invoke('dish-write', ...)"
      pattern: "invoke.*dish-write"
    - from: "src/screens/Admin/tabs/DishesTab.tsx"
      to: "supabase/functions/dish-delete"
      via: "supabase.functions.invoke('dish-delete', ...)"
      pattern: "invoke.*dish-delete"
    - from: "src/screens/Admin/modals/AddDishModal.tsx"
      to: "src/hooks/usePhotoUpload.ts"
      via: "usePhotoUpload() for compression + upload"
      pattern: "usePhotoUpload"
    - from: "src/screens/Admin/tabs/DishesTab.tsx"
      to: "src/store/competitionStore.ts"
      via: "reads dishes from store, updates after mutations"
      pattern: "useCompetitionStore"
---

<objective>
Build the complete Dishes feature: Edge Functions for write/delete, UI components (DishCard, PhotoGrid, AddDishModal, ConfirmModal), and the wired DishesTab. Also add Storage upload policy so anon clients can upload photos.

Purpose: This is the core CRUD feature of Phase 02 ‚Äî admin must be able to create, edit, and delete dishes with photos. Requires both backend (Edge Functions) and frontend (components + tab) in a single vertical slice.
Output: Fully functional DishesTab where admin can add/edit/delete dishes with compressed photo uploads. Edge Functions deployed and callable.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-admin-dishes/02-RESEARCH.md
@.planning/phases/02-admin-dishes/02-01-SUMMARY.md

Key existing files to reference:
@supabase/functions/competition-create/index.ts (Edge Function pattern: Deno + zod + service_role + CORS)
@supabase/functions/competition-join/index.ts (Auth verification pattern: participantId in body, role check via DB)
@src/store/competitionStore.ts (created in 02-01)
@src/hooks/usePhotoUpload.ts (created in 02-01)
@src/hooks/useCompetition.ts (created in 02-01)
@src/components/ui/index.ts (Button, Input, Modal, Toast)
@src/types/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Storage migration + Edge Functions dish-write and dish-delete</name>
  <files>
    supabase/functions/dish-write/index.ts
    supabase/functions/dish-delete/index.ts
  </files>
  <action>
    **0. Add Storage anon upload policy via supabase-local MCP**
    Apply migration `02_storage_upload_policy`:
    ```sql
    CREATE POLICY "anon_upload_dish_photos"
      ON storage.objects FOR INSERT
      WITH CHECK (bucket_id = 'dish-photos');
    ```
    This allows anon SDK clients to upload photos directly. Research recommends Option A.

    **1. Create `supabase/functions/dish-write/index.ts`**
    Follow EXACTLY the pattern from competition-create/competition-join Edge Functions (Deno, npm: imports, CORS headers, OPTIONS preflight, service_role client).

    Zod schema:
    ```typescript
    const DishWriteSchema = z.object({
      competitionId: z.string().uuid(),
      participantId: z.string().uuid(),
      dishId: z.string().uuid().optional(),       // present = edit, absent = create
      name: z.string().min(1).max(100),
      chefName: z.string().min(1).max(50),
      ingredients: z.string().max(2000).optional().default(''),
      recipe: z.string().max(5000).optional().default(''),
      story: z.string().max(2000).optional().default(''),
      photoUrls: z.array(z.string().url()).max(10).optional().default([]),
      isExtra: z.boolean().optional().default(false),
    })
    ```

    Authorization logic:
    1. Fetch participant by ID from participants table using service_role
    2. Verify participant belongs to the competitionId
    3. If participant.role === 'admin': allow any dish write (DISH-01, DISH-04)
    4. If participant.role !== 'admin':
       - Fetch competition to check phase
       - If phase !== 'preparation': return 403 "Piatti modificabili solo in fase preparazione"
       - If creating: check no existing dish for this participant (max 1, DISH-02)
       - If editing: verify dish.participant_id === participantId (own dish only, DISH-03)

    Mutation logic:
    - CREATE (no dishId): INSERT into dishes, INSERT photo records into photos table
    - EDIT (dishId present): UPDATE dish record, UPSERT photos (delete old photos for this dish, insert new ones)
    - For photos: insert one row per URL into `photos` table with `dish_id`, `url`, `order` (index), `is_extra`

    Return: `{ dish: DishRow, photos: PhotoRow[] }` with 201 (create) or 200 (edit)

    Error responses: 400 (validation), 403 (not authorized / wrong phase), 404 (participant/dish not found)

    **2. Create `supabase/functions/dish-delete/index.ts`**
    Follow same Edge Function pattern.

    Zod schema:
    ```typescript
    const DishDeleteSchema = z.object({
      competitionId: z.string().uuid(),
      participantId: z.string().uuid(),
      dishId: z.string().uuid(),
    })
    ```

    Authorization: Only admin can delete (DISH-04). Verify participant.role === 'admin'.

    Deletion pipeline (ORDER MATTERS ‚Äî Pitfall 6 from research):
    1. Fetch photo URLs from `photos` table WHERE dish_id = dishId
    2. Extract Storage paths from URLs (strip the public base URL prefix)
    3. Delete Storage objects via `service_role` client: `storage.from('dish-photos').remove(paths)`
    4. DELETE from dishes WHERE id = dishId (CASCADE removes photos and votes rows)

    Return: `{ success: true }` with 200

    **3. Deploy both Edge Functions via supabase-local MCP with verify_jwt: false**
    Use the same deployment approach as competition-create and competition-join.
  </action>
  <verify>
    Both Edge Function files exist and follow the established Deno pattern. Storage migration applied. Functions deployed via MCP.
  </verify>
  <done>
    dish-write creates/updates dishes with photos and enforces role+phase authorization. dish-delete removes Storage blobs before cascading DB delete. Both deployed with verify_jwt: false. Storage anon upload policy active.
  </done>
</task>

<task type="auto">
  <name>Task 2: DishCard + PhotoGrid + AddDishModal + ConfirmModal + DishesTab wiring</name>
  <files>
    src/components/dishes/DishCard.tsx
    src/components/dishes/PhotoGrid.tsx
    src/screens/Admin/modals/AddDishModal.tsx
    src/screens/Admin/modals/ConfirmModal.tsx
    src/screens/Admin/tabs/DishesTab.tsx
    src/screens/Admin/AdminScreen.tsx
  </files>
  <action>
    **1. Create `src/components/dishes/PhotoGrid.tsx`**
    Props: `{ photos: Photo[], maxDisplay?: number }` where Photo is from database.types.
    - Grid layout: 3 columns, gap-1, rounded-lg overflow-hidden
    - If 1 photo: full-width single image
    - If 2 photos: 2-column layout
    - If 3+ photos: 3-column grid, first photo spans 2 columns if odd count
    - Images: object-cover, aspect-square
    - If maxDisplay set and photos.length > maxDisplay: show "+N" overlay on last visible photo

    **2. Create `src/components/dishes/DishCard.tsx`**
    Props: `{ dish: DishWithPhotos, onEdit?: () => void, onDelete?: () => void, showActions?: boolean }`
    - Card with rounded-xl, shadow-sm, bg-white, overflow-hidden
    - Top: PhotoGrid (max 3 photos displayed)
    - Body: dish name (font-display, text-lg, font-bold), chef name (text-sm, text-gray-500, prefixed "üë®‚Äçüç≥"), ingredients preview (first 80 chars + "..." if longer)
    - Footer (if showActions): Edit button (ghost) and Delete button (ghost, red text) using existing Button component
    - If no photos: show placeholder with "üì∑ Nessuna foto" centered

    **3. Create `src/screens/Admin/modals/ConfirmModal.tsx`**
    Props: `{ open: boolean, onClose: () => void, onConfirm: () => void, title: string, message: string, confirmLabel?: string, confirmVariant?: 'ember' | 'gold', isLoading?: boolean }`
    - Uses existing Modal component with variant='center'
    - Title (font-display), message paragraph, two buttons: "Annulla" (ghost) and confirm (ember or specified variant)
    - isLoading disables confirm button and shows spinner

    **4. Create `src/screens/Admin/modals/AddDishModal.tsx`**
    Props: `{ open: boolean, onClose: () => void, editDish?: DishWithPhotos | null }`
    - Uses existing Modal component with variant='bottom-sheet'
    - Title: "Aggiungi piatto" or "Modifica piatto" based on editDish
    - Form fields using existing Input component:
      - Nome piatto* (required)
      - Nome cuoco* (required)
      - Ingredienti (textarea-style, optional)
      - Ricetta (textarea-style, optional)
      - Storia (textarea-style, optional)
    - Photo section:
      - Show existing photos as thumbnail grid (if editing)
      - "Aggiungi foto" button opens file input (accept="image/*", multiple)
      - Selected files shown as thumbnails with remove button
      - File input is hidden, triggered by button click
    - Submit flow:
      1. If new photos selected: call `usePhotoUpload().uploadPhotos(files, dishId)`
      2. Combine existing photo URLs + new URLs
      3. Call `supabase.functions.invoke('dish-write', { body: { ... } })`
      4. On success: update competitionStore (addDish or updateDish), show Toast, close modal
      5. On error: show error via Toast
    - For new dish: generate a temporary UUID for dishId (needed for photo upload path) ‚Äî the Edge Function will use it as the actual dish ID if provided as `dishId` in create mode, OR let the EF generate one. Simplest: upload photos with a temp folder name, then pass URLs to EF.
      Actually: For CREATE, upload photos to a temp UUID path, send that UUID as `dishId` to dish-write so it uses it. The EF should accept `dishId` for create too and use it as the PK.
    - Pre-fill form when `editDish` is provided
    - Get participantId from sessionStore for the current competition code

    **5. Create `src/screens/Admin/tabs/DishesTab.tsx`**
    - Read dishes from competitionStore
    - Render list of DishCard components with showActions=true
    - "Aggiungi piatto" floating action button (FAB) at bottom-right: opens AddDishModal
    - Edit action: opens AddDishModal with editDish prop
    - Delete action: opens ConfirmModal, on confirm calls `supabase.functions.invoke('dish-delete', ...)`
    - After successful delete: call competitionStore.removeDish(dishId), show success Toast
    - Empty state: "Nessun piatto ancora. Aggiungi il primo!" centered with emoji "üç≥"
    - Refresh: after dish-write/delete success, re-fetch dishes to get fresh data with photos join (or optimistically update store)

    **6. Update `src/screens/Admin/AdminScreen.tsx`**
    Replace the DishesTab placeholder with the actual `<DishesTab />` component import. Keep other tab placeholders for Plan 02-03.
  </action>
  <verify>
    Run `npm run build` ‚Äî zero errors. AdminScreen DishesTab renders dish cards. AddDishModal opens and has all form fields. ConfirmModal renders with title/message/buttons.
  </verify>
  <done>
    DishesTab shows all dishes as DishCards with photo grids. Admin can click "Aggiungi piatto" to open AddDishModal, fill form with photos, and create a dish. Admin can edit (pre-filled modal) and delete (with ConfirmModal) any dish. Photos compressed before upload. Store updated after mutations.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Dishes feature: Edge Functions (dish-write, dish-delete), Storage upload, AdminScreen with DishesTab showing DishCards, AddDishModal with photo upload + compression, ConfirmModal for delete confirmation.</what-built>
  <how-to-verify>
    1. Open the app and create a competition (or use an existing one)
    2. Navigate to the admin panel
    3. Verify DishesTab is active by default, showing empty state
    4. Click "Aggiungi piatto" ‚Äî AddDishModal should open as bottom-sheet
    5. Fill: name="Carbonara", chef="Marco", add 1-2 photos from device
    6. Submit ‚Äî dish should appear as DishCard with photo, name, chef
    7. Click edit on the dish ‚Äî modal reopens with pre-filled data
    8. Change the name, submit ‚Äî card updates
    9. Click delete ‚Äî ConfirmModal appears, confirm ‚Äî dish removed
    10. Verify tabs switch correctly (other 3 show placeholders)
    11. Check browser console: no errors, photos uploaded to dish-photos bucket
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. dish-write Edge Function creates/edits dishes with role+phase authorization
4. dish-delete Edge Function removes Storage blobs then cascades DB delete
5. Storage anon upload policy allows client-side photo uploads
6. DishCard renders photo grid, name, chef, action buttons
7. AddDishModal creates and edits dishes with photo upload
8. ConfirmModal shows confirmation before destructive actions
9. DishesTab wires everything together with competitionStore
</verification>

<success_criteria>
- Admin can create a dish with name, chef, optional fields, and photos
- Admin can edit any dish
- Admin can delete any dish (with confirmation, Storage blobs cleaned up)
- Photos compressed to max 800px / 0.72 JPEG before upload
- DishesTab reads from competitionStore and updates after mutations
- Non-admin cannot write dishes outside preparation phase (EF enforcement)
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-dishes/02-02-SUMMARY.md`
</output>
