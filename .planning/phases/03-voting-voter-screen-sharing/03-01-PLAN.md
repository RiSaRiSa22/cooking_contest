---
phase: 03-voting-voter-screen-sharing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/vote-cast/index.ts
  - supabase/functions/vote-read/index.ts
  - src/store/voterStore.ts
  - src/hooks/useVoterData.ts
  - src/screens/Voter/VoterScreen.tsx
  - src/screens/Voter/tabs/VoteTab.tsx
  - src/router.tsx
  - src/screens/Home/HomeScreen.tsx
autonomous: true

must_haves:
  truths:
    - "Un partecipante in fase voting vede la lista dei piatti e puo votarne esattamente 1 (non il proprio)"
    - "Il voto puo essere cambiato (sovrascrive il precedente tramite upsert atomico)"
    - "I nomi dei cuochi sono nascosti nel VoteTab (dishes_public restituisce chef_name=null in voting)"
    - "mode=vote deep link apre la JoinCompModal come mode=join"
    - "VoterScreen ha shell con header, PhaseBanner, tab bar (4 tab, classifica nascosta se non finished)"
  artifacts:
    - path: "supabase/functions/vote-cast/index.ts"
      provides: "Upsert atomico voto con verifiche (phase=voting, non proprio piatto)"
      exports: ["Deno.serve handler"]
    - path: "supabase/functions/vote-read/index.ts"
      provides: "Lettura voto corrente + myDishId + vote counts per classifica"
      exports: ["Deno.serve handler"]
    - path: "src/store/voterStore.ts"
      provides: "Zustand store per dati voter (dishes da dishes_public, myVote, myDishId, voteCounts)"
    - path: "src/hooks/useVoterData.ts"
      provides: "Hook che carica dati da dishes_public + vote-read EF"
    - path: "src/screens/Voter/VoterScreen.tsx"
      provides: "Shell screen con header, PhaseBanner, tab bar, content area"
    - path: "src/screens/Voter/tabs/VoteTab.tsx"
      provides: "Lista piatti votabili con stato voto e azione vota/cambia"
  key_links:
    - from: "src/screens/Voter/tabs/VoteTab.tsx"
      to: "supabase/functions/vote-cast"
      via: "supabase.functions.invoke('vote-cast')"
      pattern: "functions\\.invoke.*vote-cast"
    - from: "src/hooks/useVoterData.ts"
      to: "supabase/functions/vote-read"
      via: "supabase.functions.invoke('vote-read')"
      pattern: "functions\\.invoke.*vote-read"
    - from: "src/hooks/useVoterData.ts"
      to: "dishes_public view"
      via: "supabase.from('dishes_public')"
      pattern: "from.*dishes_public"
    - from: "src/router.tsx"
      to: "src/screens/Voter/VoterScreen.tsx"
      via: "router config path /voter/:code"
      pattern: "VoterScreen"
---

<objective>
Implementare il flusso di voto completo: Edge Functions per cast e read del voto, data layer voter (store + hook), VoterScreen shell con tab navigation, e VoteTab con lista piatti votabili. Aggiungere mode=vote deep link.

Purpose: Questo e il core value dell'app ‚Äî i partecipanti possono finalmente votare in modo anonimo. Senza questa slice, l'app non ha funzionalita di voto.

Output: 2 Edge Functions deployate (vote-cast, vote-read), voterStore, useVoterData hook, VoterScreen con VoteTab funzionante, mode=vote deep link.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-voting-voter-screen-sharing/03-RESEARCH.md

# Key existing files to reference
@supabase/functions/dish-write/index.ts          # EF pattern: CORS, zod, service_role, error handling
@src/store/competitionStore.ts                     # Zustand store pattern (no persist, reset on unmount)
@src/hooks/useCompetition.ts                       # Data fetch + Realtime pattern
@src/screens/Admin/AdminScreen.tsx                 # Screen shell pattern (header, PhaseBanner, tabs)
@src/screens/Admin/tabs/DishesTab.tsx              # Tab component pattern
@src/router.tsx                                    # Router with RequireSession guard
@src/screens/Home/HomeScreen.tsx                   # Deep link handling (mode=join/reauth)
@src/types/database.types.ts                       # DishPublic type, votes table schema
@src/components/competition/PhaseBanner.tsx         # Shared component
</context>

<tasks>

<task type="auto">
  <name>Task 1: vote-cast e vote-read Edge Functions</name>
  <files>supabase/functions/vote-cast/index.ts, supabase/functions/vote-read/index.ts</files>
  <action>
  Creare due Edge Functions seguendo esattamente il pattern di `dish-write/index.ts` (CORS headers, zod validation, service_role client, error handling).

  **vote-cast/index.ts:**
  - Schema zod: `{ competitionId: uuid, participantId: uuid, dishId: uuid }`
  - Verifiche in ordine:
    1. Participant esiste e `competition_id === competitionId`
    2. Competition `phase === 'voting'` (altrimenti 400 "Votazione non in corso")
    3. Dish esiste e `competition_id === competitionId` (altrimenti 400 "Piatto non in questa gara")
    4. `dish.participant_id !== participantId` (altrimenti 400 "Non puoi votare il tuo piatto")
  - Upsert atomico: `supabase.from('votes').upsert({ competition_id, participant_id, dish_id }, { onConflict: 'competition_id,participant_id' }).select().single()`
  - Response 200: `{ vote }` con il record upsertato

  **vote-read/index.ts:**
  - Schema zod: `{ competitionId: uuid, participantId: uuid }`
  - Verifiche: participant esiste e `competition_id === competitionId`
  - Tre query parallele con Promise.all:
    1. Voto corrente del partecipante: `votes WHERE competition_id AND participant_id ‚Üí maybeSingle()` ‚Üí `myVotedDishId: string | null`
    2. Piatto del partecipante: `dishes WHERE competition_id AND participant_id ‚Üí maybeSingle()` ‚Üí `myDishId: string | null`
    3. Conteggio voti per piatto: query SQL raw o aggregazione ‚Äî selezionare tutti i voti della competizione, aggregare per dish_id ‚Üí `voteCounts: Array<{ dish_id: string, count: number }>`
       Per il conteggio usare: `supabase.from('votes').select('dish_id').eq('competition_id', competitionId)` e poi aggregare lato JS (Map dish_id ‚Üí count). Alternativa: usare `supabase.rpc()` ma e overengineering ‚Äî aggregare 5-20 righe in JS e perfettamente fine.
  - Response 200: `{ myVotedDishId, myDishId, voteCounts }`

  Deployare entrambe via MCP `supabase-local` con `verify_jwt: false` (stesso pattern delle altre EF del progetto).
  </action>
  <verify>
  Deploy successful via supabase-local MCP. Test manuale con curl o via MCP:
  - vote-cast con dati validi ‚Üí 200 con vote record
  - vote-cast stesso participantId ‚Üí 200 (upsert aggiorna dish_id)
  - vote-cast phase !== voting ‚Üí 400
  - vote-cast proprio piatto ‚Üí 400
  - vote-read ‚Üí 200 con myVotedDishId, myDishId, voteCounts
  </verify>
  <done>Entrambe le EF deployate e raggiungibili. vote-cast esegue upsert atomico con tutte le verifiche. vote-read restituisce voto corrente, piatto del partecipante, e conteggi voti.</done>
</task>

<task type="auto">
  <name>Task 2: voterStore + useVoterData + VoterScreen shell + router wiring + mode=vote</name>
  <files>src/store/voterStore.ts, src/hooks/useVoterData.ts, src/screens/Voter/VoterScreen.tsx, src/router.tsx, src/screens/Home/HomeScreen.tsx</files>
  <action>
  **voterStore.ts** ‚Äî Zustand store (NO persist middleware, pattern identico a competitionStore):
  ```typescript
  interface VoterStore {
    competition: Competition | null
    dishes: DishPublicWithPhotos[]  // da dishes_public view
    myVotedDishId: string | null    // dish_id votato attualmente
    myDishId: string | null         // dish_id del partecipante (per disabilitare nel VoteTab)
    voteCounts: Map<string, number> // dish_id ‚Üí numero voti
    isLoading: boolean
    error: string | null
    // setters per ogni campo + reset()
  }
  ```
  Tipo `DishPublicWithPhotos`: importare `DishPublic` da database.types.ts + Photo. NOTA: `DishPublic` ha campi nullable (e una view) ‚Äî `id: string | null`, `name: string | null`, etc. Per comodita definire il tipo con non-null assertion dopo il fetch (filtrare righe con id null).

  **Importante sulla query dishes_public + photos:**
  Prima tentare `supabase.from('dishes_public').select('*, photos(*)').eq('competition_id', competitionId)`. Se funziona, usare direttamente. Se non funziona (PostgREST non risolve la FK sulla view), piano B: due query separate ‚Äî (1) dishes_public, (2) photos WHERE dish_id IN (...) ‚Äî e join manuale in JS. La relazione `photos.dish_id ‚Üí dishes_public.id` esiste nei types (`Relationships` di photos include `dishes_public`), quindi dovrebbe funzionare. Testare al primo run.

  **useVoterData.ts** ‚Äî Hook che:
  1. Carica competition + dishes_public con photos in parallelo (Promise.all)
  2. Chiama vote-read EF per myVotedDishId, myDishId, voteCounts
  3. Setta tutto nel voterStore
  4. Subscribe a Realtime per phase changes (stesso pattern di useCompetition)
  5. reset() on unmount + cleanup Realtime channel

  **VoterScreen.tsx** ‚Äî Mirror esatto di AdminScreen.tsx:
  - `useParams` per `code`, `useSessionStore` per session
  - `useVoterData(session.competitionId, session.participantId)`
  - Sticky header (62px) con nome competizione e codice badge
  - PhaseBanner (componente condiviso)
  - Tab bar in basso (64px) con 4 tab:
    ```typescript
    const TABS = [
      { id: 'vota', label: 'Vota', emoji: 'üó≥Ô∏è' },
      { id: 'galleria', label: 'Galleria', emoji: 'üì∏' },
      { id: 'classifica', label: 'Classifica', emoji: 'üèÜ' },
      { id: 'il-mio-piatto', label: 'Il mio piatto', emoji: 'üçΩÔ∏è' },
    ]
    ```
  - Tab Classifica: **nascondere fisicamente il tab** quando `phase !== 'finished'` (VOTR-03: "visibile solo in fase finished"). Quando nascosto, la tab bar mostra solo 3 tab.
  - Scrollable content area con pb-24 per tab bar
  - Loading/error states identici ad AdminScreen
  - Per ora, GalleryTab, RankingTab, MyDishTab renderizzano placeholder `<div>Coming soon</div>`. VoteTab e implementato nel Task 3.

  **router.tsx** ‚Äî Sostituire il placeholder `/voter/:code` con:
  ```tsx
  import { VoterScreen } from './screens/Voter/VoterScreen'
  // ...
  { path: '/voter/:code', element: <RequireSession><VoterScreen /></RequireSession> }
  ```

  **HomeScreen.tsx** ‚Äî Aggiungere gestione `mode=vote` nel deep link handler:
  ```typescript
  } else if (mode === 'vote') {
    setDeepLinkCode(upperCode)
    setShowJoin(true)   // stesso comportamento di mode=join
  }
  ```
  </action>
  <verify>
  - `npm run build` compila senza errori TypeScript
  - Navigare a `/#/voter/CODICE` ‚Üí VoterScreen con header, PhaseBanner, tab bar (3 tab se non finished)
  - voterStore carica dati da dishes_public e vote-read EF
  - `/#/?code=CODICE&mode=vote` ‚Üí apre JoinCompModal
  </verify>
  <done>VoterScreen shell renderizza con header, PhaseBanner, 3-4 tab (classifica solo in finished). voterStore e useVoterData caricano dati da dishes_public e vote-read. Router e deep link mode=vote funzionanti.</done>
</task>

<task type="auto">
  <name>Task 3: VoteTab ‚Äî lista piatti votabili con azione voto</name>
  <files>src/screens/Voter/tabs/VoteTab.tsx</files>
  <action>
  Implementare VoteTab che mostra:

  **1. Status bar in cima** (VOTR-01):
  - Se phase !== 'voting': banner informativo "Le votazioni non sono ancora aperte" (preparation) o "Votazioni concluse" (finished)
  - Se phase === 'voting' e ha votato: "Hai votato: [nome piatto] ‚úÖ" con sfondo verde chiaro
  - Se phase === 'voting' e non ha votato: "Scegli il piatto da votare" con sfondo giallo chiaro

  **2. Lista piatti votabili** (solo in phase === 'voting'):
  - Ogni piatto come card: foto hero (prima foto), nome piatto, "üé≠ Cuoco misterioso" (chef_name e null dalla view in voting)
  - Il proprio piatto (dish.id === myDishId dal voterStore) e visibile ma con overlay "Il tuo piatto" e non cliccabile
  - Il piatto votato ha bordo ember e checkmark
  - Tap su un piatto diverso dal votato ‚Üí chiama `supabase.functions.invoke('vote-cast', { body: { competitionId, participantId, dishId } })`
  - Dopo voto OK ‚Üí aggiorna `voterStore.myVotedDishId`
  - Gestire stato loading durante il voto (disabilitare altri tap)
  - Gestire errore dalla EF (toast con messaggio)

  **3. Empty state** se non ci sono piatti

  **Stile:** seguire il design system esistente:
  - Card: bg-white, rounded-xl, shadow-sm, border parchment-deep
  - Foto: rounded-t-xl, object-cover, h-40 (se presente)
  - Testo: font-body per body, font-display per titoli
  - Colori: var(--color-ember), var(--color-ink), var(--color-ink-light), var(--color-parchment)
  - Animazione: transizione bordo/ombra sul piatto selezionato

  **Note di implementazione:**
  - `myDishId` puo essere `null` (ospite senza piatto) ‚Üí nessun piatto disabilitato
  - Ordinare i piatti per nome (localeCompare) per consistenza
  - Usare `useToast` per errori (pattern gia usato in DishesTab)
  </action>
  <verify>
  - `npm run build` compila senza errori
  - In fase voting: lista piatti visibile, proprio piatto disabilitato (se ha un piatto)
  - Click su piatto ‚Üí voto registrato, card mostra checkmark
  - Click su altro piatto ‚Üí voto cambiato
  - In fase preparation/finished ‚Üí messaggio appropriato
  </verify>
  <done>VoteTab mostra lista piatti votabili con status bar, disabilita il proprio piatto, permette di votare e cambiare voto con feedback visivo. Errori gestiti con toast.</done>
</task>

</tasks>

<verification>
1. `npm run build` compila senza errori TypeScript
2. EFs vote-cast e vote-read deployate e raggiungibili
3. VoterScreen renderizza correttamente con header, PhaseBanner, tab bar
4. VoteTab permette di votare un piatto (non il proprio) e cambiare voto
5. mode=vote deep link apre JoinCompModal
6. Tab Classifica nascosta quando phase !== 'finished'
7. chef_name non visibile in VoteTab (dishes_public restituisce null in voting)
</verification>

<success_criteria>
- vote-cast EF esegue upsert atomico con tutte le verifiche (phase, ownership, competition)
- vote-read EF restituisce myVotedDishId, myDishId, voteCounts
- VoterScreen ha struttura identica ad AdminScreen (header, PhaseBanner, tab bar)
- VoteTab mostra piatti, permette voto/cambio voto, disabilita proprio piatto
- Build TypeScript passa senza errori
</success_criteria>

<output>
After completion, create `.planning/phases/03-voting-voter-screen-sharing/03-01-SUMMARY.md`
</output>
