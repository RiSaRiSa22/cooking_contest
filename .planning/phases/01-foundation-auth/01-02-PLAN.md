---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260221000000_initial_schema.sql
  - supabase/config.toml
  - src/types/database.types.ts
  - src/lib/supabase.ts
autonomous: true

must_haves:
  truths:
    - "All 5 tables exist (competitions, participants, dishes, photos, votes) with correct columns and constraints"
    - "dishes_public view hides chef_name and participant_id when phase != 'finished'"
    - "RLS is enabled on all tables and anon users can only read via dishes_public view"
    - "login_attempts table exists for rate limiting"
    - "Storage bucket dish-photos exists"
    - "TypeScript types are generated and importable"
  artifacts:
    - path: "supabase/migrations/20260221000000_initial_schema.sql"
      provides: "Complete schema: 5 tables + view + RLS + indexes + storage bucket"
      contains: "security_invoker = true"
    - path: "src/types/database.types.ts"
      provides: "Auto-generated TypeScript types from Supabase schema"
      contains: "Database"
    - path: "src/lib/supabase.ts"
      provides: "Supabase client singleton with Database generic"
      contains: "createClient<Database>"
  key_links:
    - from: "src/lib/supabase.ts"
      to: "src/types/database.types.ts"
      via: "type import"
      pattern: "import.*Database.*database.types"
    - from: "dishes_public view"
      to: "dishes + competitions tables"
      via: "JOIN with CASE WHEN phase check"
      pattern: "CASE WHEN c.phase = 'finished'"
---

<objective>
Create the complete Supabase database schema (5 tables, dishes_public view, RLS policies, rate limiting table, storage bucket) and generate TypeScript types.

Purpose: The database is the backbone — all auth, dishes, and voting features depend on this schema existing with correct security policies.
Output: A single migration file with the full schema, auto-generated TypeScript types, and a typed Supabase client singleton.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md — Pattern 5 (Supabase client), Pattern 7 (dishes_public view), Pattern 8 (rate limiting)
@FEATURES.md — Section 2 (Data Model), Section 12 (Security Rules)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migration with full schema, RLS, and storage</name>
  <files>
    supabase/migrations/20260221000000_initial_schema.sql
    supabase/config.toml
  </files>
  <action>
    Initialize Supabase in the project if not already done: `npx supabase init` (creates `supabase/` directory with config.toml).

    Create migration file `supabase/migrations/20260221000000_initial_schema.sql` with the following (derive from FEATURES.md Section 2):

    **Enable extensions:**
    ```sql
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    ```

    **competitions table:**
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `code` text NOT NULL UNIQUE — 6 chars uppercase alphanumeric
    - `name` text NOT NULL
    - `admin_pwd_hash` text NOT NULL
    - `phase` text NOT NULL DEFAULT 'preparation' CHECK (phase IN ('preparation', 'voting', 'finished'))
    - `allow_guests` boolean NOT NULL DEFAULT false
    - `max_participants` integer — nullable, no limit by default
    - `created_at` timestamptz DEFAULT now() NOT NULL

    **participants table:**
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `competition_id` uuid NOT NULL REFERENCES competitions(id) ON DELETE CASCADE
    - `nickname` text NOT NULL
    - `pin_hash` text NOT NULL
    - `role` text NOT NULL DEFAULT 'participant' CHECK (role IN ('admin', 'participant'))
    - `joined_at` timestamptz DEFAULT now() NOT NULL
    - UNIQUE(competition_id, nickname)

    **dishes table:**
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `competition_id` uuid NOT NULL REFERENCES competitions(id) ON DELETE CASCADE
    - `participant_id` uuid REFERENCES participants(id) ON DELETE SET NULL — null if added by admin without a participant
    - `name` text NOT NULL
    - `chef_name` text NOT NULL
    - `ingredients` text
    - `recipe` text
    - `story` text
    - `created_at` timestamptz DEFAULT now() NOT NULL

    **photos table:**
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `dish_id` uuid NOT NULL REFERENCES dishes(id) ON DELETE CASCADE
    - `url` text NOT NULL
    - `is_extra` boolean NOT NULL DEFAULT false
    - `order` integer NOT NULL DEFAULT 0
    - `created_at` timestamptz DEFAULT now() NOT NULL

    **votes table:**
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `competition_id` uuid NOT NULL REFERENCES competitions(id) ON DELETE CASCADE
    - `participant_id` uuid NOT NULL REFERENCES participants(id) ON DELETE CASCADE
    - `dish_id` uuid NOT NULL REFERENCES dishes(id) ON DELETE CASCADE
    - `created_at` timestamptz DEFAULT now() NOT NULL
    - UNIQUE(competition_id, participant_id) — one vote per participant per competition

    **login_attempts table** (rate limiting, from RESEARCH.md Pattern 8):
    - `id` uuid DEFAULT gen_random_uuid() PRIMARY KEY
    - `competition_code` text NOT NULL
    - `nickname` text NOT NULL
    - `attempted_at` timestamptz DEFAULT now() NOT NULL
    - INDEX on (competition_code, nickname, attempted_at)

    **dishes_public view** (from RESEARCH.md Pattern 7):
    ```sql
    CREATE VIEW dishes_public
    WITH (security_invoker = true)
    AS
      SELECT
        d.id,
        d.competition_id,
        d.name,
        d.ingredients,
        d.recipe,
        d.story,
        d.created_at,
        CASE WHEN c.phase = 'finished' THEN d.chef_name ELSE NULL END AS chef_name,
        CASE WHEN c.phase = 'finished' THEN d.participant_id ELSE NULL END AS participant_id
      FROM dishes d
      JOIN competitions c ON c.id = d.competition_id;
    ```

    **RLS policies:**

    Enable RLS on ALL tables: `ALTER TABLE {table} ENABLE ROW LEVEL SECURITY;`

    For `competitions`:
    - SELECT: allow anon to read by code — `CREATE POLICY "anon_read_competitions" ON competitions FOR SELECT USING (true);`
    - INSERT/UPDATE/DELETE: deny anon (service_role via Edge Functions only)

    For `participants`:
    - SELECT: allow anon to read participants of a competition (needed for nickname conflict check)
    - INSERT/UPDATE/DELETE: deny anon

    For `dishes`:
    - SELECT: DENY direct anon access to dishes table (force use of dishes_public view)
    - `CREATE POLICY "block_anon_direct_read" ON dishes FOR SELECT USING (false);`
    - INSERT/UPDATE/DELETE: deny anon

    For `dishes_public` (view with security_invoker): the SELECT on dishes will fail for anon because of the policy above. Fix: create a separate policy that allows the security invoker context. Actually, with `security_invoker = true`, the view runs as the calling user (anon). So we need a policy that allows reading dishes THROUGH the view. The simplest approach: allow SELECT on dishes for anon but ONLY through the view by granting SELECT on the view and not on the table directly. In Postgres, views with security_invoker need the underlying table to allow SELECT for the invoking role.

    Revised approach for dishes RLS:
    - Allow SELECT for anon on dishes table (the view with security_invoker handles column filtering)
    - The view already hides chef_name and participant_id when phase != 'finished'
    - Participants read via the view (frontend always queries dishes_public, never dishes directly)
    - `CREATE POLICY "anon_read_dishes" ON dishes FOR SELECT USING (true);`

    For `photos`:
    - SELECT: allow anon read (photos are public within a competition)
    - INSERT/UPDATE/DELETE: deny anon

    For `votes`:
    - SELECT: deny anon (only admin via service_role sees who voted)
    - INSERT/UPDATE/DELETE: deny anon

    For `login_attempts`:
    - All operations: deny anon (Edge Functions use service_role)

    **Storage bucket:**
    ```sql
    INSERT INTO storage.buckets (id, name, public) VALUES ('dish-photos', 'dish-photos', true);
    ```
    Add storage policy for public read and authenticated upload (or handle via Edge Function).

    **Useful indexes:**
    - `CREATE INDEX idx_competitions_code ON competitions(code);`
    - `CREATE INDEX idx_participants_competition ON participants(competition_id);`
    - `CREATE INDEX idx_dishes_competition ON dishes(competition_id);`
    - `CREATE INDEX idx_photos_dish ON photos(dish_id);`
    - `CREATE INDEX idx_votes_competition ON votes(competition_id);`
    - `CREATE INDEX idx_votes_dish ON votes(dish_id);`

    Apply the migration using the supabase-local MCP: `apply_migration` tool.
  </action>
  <verify>
    Use supabase-local MCP `list_tables` to verify all tables exist in public schema.
    Use supabase-local MCP `execute_sql` to:
    1. `SELECT * FROM dishes_public LIMIT 0;` — view exists
    2. `SELECT column_name FROM information_schema.columns WHERE table_name = 'competitions';` — verify all columns
    3. Verify RLS is enabled: `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public';`
  </verify>
  <done>
    All 5 tables + login_attempts + dishes_public view exist with correct columns, constraints, indexes, RLS policies enabled, and storage bucket created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript types and create Supabase client singleton</name>
  <files>
    src/types/database.types.ts
    src/lib/supabase.ts
  </files>
  <action>
    **Generate types** using supabase-local MCP `generate_typescript_types` tool. Save the output to `src/types/database.types.ts`.

    If the MCP type generation doesn't include the dishes_public view, manually add the view type after the generated types:
    ```typescript
    // Convenience type for the dishes_public view (auto-filtered by phase)
    export type DishPublic = Database['public']['Views']['dishes_public']['Row']
    ```

    **Create Supabase client** at `src/lib/supabase.ts` following RESEARCH.md Pattern 5:
    ```typescript
    import { createClient } from '@supabase/supabase-js'
    import type { Database } from '../types/database.types'

    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
    const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error('Missing VITE_SUPABASE_URL or VITE_SUPABASE_ANON_KEY env vars')
    }

    export const supabase = createClient<Database>(
      supabaseUrl,
      supabaseAnonKey,
      {
        auth: {
          persistSession: false,  // custom PIN auth, no Supabase Auth
        },
      }
    )
    ```

    Important: `persistSession: false` per PROJECT.md — we use custom session management, not Supabase Auth.
  </action>
  <verify>
    TypeScript compilation check: `npx tsc --noEmit` on `src/lib/supabase.ts` and `src/types/database.types.ts` — no type errors.
    Verify `Database` type includes tables: competitions, participants, dishes, photos, votes.
    Verify `DishPublic` type exists with nullable chef_name and participant_id.
  </verify>
  <done>
    TypeScript types are generated from the live schema, Database type is importable, Supabase client singleton is typed and configured with persistSession: false.
  </done>
</task>

</tasks>

<verification>
1. All 6 tables exist (competitions, participants, dishes, photos, votes, login_attempts)
2. dishes_public view exists and returns NULL for chef_name when phase != 'finished'
3. RLS is enabled on all tables
4. Storage bucket 'dish-photos' exists
5. TypeScript types compile without errors
6. Supabase client is typed with Database generic
7. Indexes exist for all foreign keys and frequent query columns
</verification>

<success_criteria>
The Supabase schema is fully operational with all tables, the dishes_public view correctly hides chef identity, RLS policies are in place, and TypeScript types are generated and importable. The Supabase client singleton is ready for use by subsequent plans.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
